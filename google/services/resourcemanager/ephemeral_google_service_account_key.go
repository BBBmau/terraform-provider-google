// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0
// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0
// ----------------------------------------------------------------------------
//
//	***     AUTO GENERATED CODE    ***    Type: Handwritten     ***
//
// ----------------------------------------------------------------------------
//
//	This code is generated by Magic Modules using the following:
//
//	Source file: https://github.com/GoogleCloudPlatform/magic-modules/tree/main/mmv1/third_party/terraform/services/resourcemanager/ephemeral_google_service_account_key.go
//
//	DO NOT EDIT this file directly. Any changes made to this file will be
//	overwritten during the next generation cycle.
//
// ----------------------------------------------------------------------------
package resourcemanager

import (
	"context"
	"encoding/json"
	"fmt"
	"regexp"
	"time"

	"github.com/hashicorp/terraform-plugin-framework-validators/ephemeralvalidator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/ephemeral"
	"github.com/hashicorp/terraform-plugin-framework/ephemeral/schema"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-provider-google/google/tpgresource"
	transport_tpg "github.com/hashicorp/terraform-provider-google/google/transport"
	"github.com/hashicorp/terraform-provider-google/google/verify"
	"google.golang.org/api/googleapi"
	"google.golang.org/api/iam/v1"
)

var _ ephemeral.EphemeralResource = &googleEphemeralServiceAccountKey{}

func GoogleEphemeralServiceAccountKey() ephemeral.EphemeralResource {
	return &googleEphemeralServiceAccountKey{}
}

type googleEphemeralServiceAccountKey struct {
	providerConfig *transport_tpg.Config
}

func (p *googleEphemeralServiceAccountKey) Metadata(ctx context.Context, req ephemeral.MetadataRequest, resp *ephemeral.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_service_account_key"
}

type ephemeralServiceAccountKeyModel struct {
	FetchKey         types.Bool   `tfsdk:"fetch_key"`
	ServiceAccountId types.String `tfsdk:"service_account_id"`
	Name             types.String `tfsdk:"name"`
	PublicKeyType    types.String `tfsdk:"public_key_type"`
	KeyAlgorithm     types.String `tfsdk:"key_algorithm"`
	PublicKeyData    types.String `tfsdk:"public_key_data"`
	PrivateKey       types.String `tfsdk:"private_key"`
	PrivateKeyType   types.String `tfsdk:"private_key_type"`
}

func (p *googleEphemeralServiceAccountKey) ConfigValidators(ctx context.Context) []ephemeral.ConfigValidator {
	return []ephemeral.ConfigValidator{
		ephemeralvalidator.Conflicting(
			path.MatchRoot("public_key_data"),
			path.MatchRoot("private_key_type"),
		),
		ephemeralvalidator.Conflicting(
			path.MatchRoot("public_key_data"),
			path.MatchRoot("key_algorithm"),
		),
		ephemeralvalidator.AtLeastOneOf(
			path.MatchRoot("service_account_id"),
			path.MatchRoot("name"),
		),
	}
}

func (p *googleEphemeralServiceAccountKey) Schema(ctx context.Context, req ephemeral.SchemaRequest, resp *ephemeral.SchemaResponse) {
	resp.Schema = schema.Schema{
		Description: "Get an ephemeral service account public key.",
		Attributes: map[string]schema.Attribute{
			"service_account_id": schema.StringAttribute{
				Description: `The ID of the parent service account of the key. This can be a string in the format {ACCOUNT} or projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT}, where {ACCOUNT} is the email address or unique id of the service account. If the {ACCOUNT} syntax is used, the project will be inferred from the provider's configuration.`,
				Optional:    true,
			},
			"name": schema.StringAttribute{
				Description: "The name of the service account key. This must have format `projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT}/keys/{KEYID}`, where `{ACCOUNT}` is the email address or unique id of the service account.",
				Optional:    true,
				Computed:    true,
				Validators: []validator.String{
					stringvalidator.RegexMatches(
						regexp.MustCompile(verify.ServiceAccountKeyNameRegex),
						"must match regex: "+verify.ServiceAccountKeyNameRegex,
					),
				}},
			"public_key_type": schema.StringAttribute{
				Description: "The output format of the public key requested. TYPE_X509_PEM_FILE is the default output format.",
				Optional:    true,
				Validators: []validator.String{
					stringvalidator.OneOf(
						"TYPE_X509_PEM_FILE",
						"TYPE_RAW_PUBLIC_KEY",
					),
				},
			},
			"key_algorithm": schema.StringAttribute{
				Description: "The algorithm used to generate the key.",
				Optional:    true,
				Computed:    true,
			},
			"public_key_data": schema.StringAttribute{
				Description: "The public key, base64 encoded.",
				Optional:    true,
			},
			"private_key": schema.StringAttribute{
				Description: "The private key, base64 encoded.",
				Optional:    true,
				Computed:    true,
			},
			"private_key_type": schema.StringAttribute{
				Description: "The type of the private key.",
				Optional:    true,
				Computed:    true,
			},
			"fetch_key": schema.BoolAttribute{
				Description: "Whether to fetch the public key.",
				Optional:    true,
			},
		},
	}
}

func (p *googleEphemeralServiceAccountKey) Configure(ctx context.Context, req ephemeral.ConfigureRequest, resp *ephemeral.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	pd, ok := req.ProviderData.(*transport_tpg.Config)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Data Source Configure Type",
			fmt.Sprintf("Expected *transport_tpg.Config, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)
		return
	}

	p.providerConfig = pd
}

type ServiceAccountKeyPrivateData struct {
	Name          string `json:"name"`
	PublicKeyType string `json:"public_key_type"`
}

var createdServiceAccountKey, retrievedServiceAccountKey bool

func (p *googleEphemeralServiceAccountKey) Open(ctx context.Context, req ephemeral.OpenRequest, resp *ephemeral.OpenResponse) {
	var data ephemeralServiceAccountKeyModel
	var err error
	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	var serviceAccountName string
	serviceAccountName, err = tpgresource.ServiceAccountFQN(data.ServiceAccountId.ValueString(), nil, p.providerConfig)
	if err != nil {
		resp.Diagnostics.AddError(
			"Error getting service account name",
			fmt.Sprintf("Error getting service account name: %s", err),
		)
		return
	}
	fmt.Printf("[DEBUG] Service Account Name %q\n", serviceAccountName)

	var serviceAccountKey *iam.ServiceAccountKey
	createdServiceAccountKey = false
	if data.PublicKeyData.ValueString() != "" {
		ru := &iam.UploadServiceAccountKeyRequest{
			PublicKeyData: data.PublicKeyData.ValueString(),
		}
		serviceAccountKey, err = p.providerConfig.NewIamClient(p.providerConfig.UserAgent).Projects.ServiceAccounts.Keys.Upload(serviceAccountName, ru).Do()
		if err != nil {
			resp.Diagnostics.AddError(
				"Error creating service account key",
				fmt.Sprintf("Error creating service account key: %s", err),
			)
			return
		}
		createdServiceAccountKey = true
	} else if !data.FetchKey.ValueBool() {
		var keyAlgorithm, privateKeyType string
		if data.PrivateKeyType.ValueString() == "" {
			privateKeyType = "TYPE_GOOGLE_CREDENTIALS_FILE"
		} else {
			privateKeyType = data.PrivateKeyType.ValueString()
		}
		if data.KeyAlgorithm.ValueString() == "" {
			keyAlgorithm = "KEY_ALG_RSA_2048"
		} else {
			keyAlgorithm = data.KeyAlgorithm.ValueString()
		}
		rc := &iam.CreateServiceAccountKeyRequest{
			KeyAlgorithm:   keyAlgorithm,
			PrivateKeyType: privateKeyType,
		}
		serviceAccountKey, err = p.providerConfig.NewIamClient(p.providerConfig.UserAgent).Projects.ServiceAccounts.Keys.Create(serviceAccountName, rc).Do()
		if err != nil {
			resp.Diagnostics.AddError(
				"Error creating service account key",
				fmt.Sprintf("Error creating service account key: %s", err),
			)
			return
		}
		createdServiceAccountKey = true
	}
	var publicKeyType string
	if !createdServiceAccountKey && !retrievedServiceAccountKey {
		retrievedServiceAccountKey = true
		if data.PublicKeyType.ValueString() == "" {
			publicKeyType = "TYPE_X509_PEM_FILE"
		} else {
			publicKeyType = data.PublicKeyType.ValueString()
		}
		data.PublicKeyType = types.StringValue(publicKeyType)
		fmt.Printf("[DEBUG] Retrieving Service Account Key %q\n", serviceAccountKey.Name)
		err = ServiceAccountKeyWaitTime(p.providerConfig.NewIamClient(p.providerConfig.UserAgent).Projects.ServiceAccounts.Keys, serviceAccountKey.Name, publicKeyType, "Retrieving Service account key", 4*time.Minute)
		if err != nil {
			resp.Diagnostics.AddError(
				"Error retrieving Service Account Key",
				fmt.Sprintf("Error retrieving Service Account Key %q: %s", serviceAccountKey.Name, err),
			)
			return
		}
	}
	if serviceAccountKey != nil {
		fmt.Printf("[DEBUG] Setting Service Account Key name %q\n", serviceAccountKey.Name)
		marshalledName, _ := json.Marshal(ServiceAccountKeyPrivateData{Name: serviceAccountKey.Name})

		resp.Private.SetKey(ctx, "name", marshalledName)

		data.Name = types.StringValue(serviceAccountKey.Name)
		data.KeyAlgorithm = types.StringValue(serviceAccountKey.KeyAlgorithm)
		data.PrivateKey = types.StringValue(serviceAccountKey.PrivateKeyData)
		data.PrivateKeyType = types.StringValue(serviceAccountKey.PrivateKeyType)
	}

	resp.Diagnostics.Append(resp.Result.Set(ctx, &data)...)
}

func (p *googleEphemeralServiceAccountKey) Close(ctx context.Context, req ephemeral.CloseRequest, resp *ephemeral.CloseResponse) {
	if !createdServiceAccountKey {
		return
	}
	serviceAccountKeyName, diags := req.Private.GetKey(ctx, "name")
	if diags.HasError() {
		resp.Diagnostics.AddError(
			"Error getting private key",
			fmt.Sprintf("Error getting private key: %s", diags.Errors()),
		)
		return
	}
	var nameData ServiceAccountKeyPrivateData
	json.Unmarshal(serviceAccountKeyName, &nameData)
	fmt.Printf("[DEBUG] Deleting Service Account Key %q\n", nameData.Name)
	_, err := p.providerConfig.NewIamClient(p.providerConfig.UserAgent).Projects.ServiceAccounts.Keys.Delete(nameData.Name).Do()
	if err != nil && err.(*googleapi.Error).Code != 404 {
		resp.Diagnostics.AddError(
			"Error deleting Service Account Key",
			fmt.Sprintf("Error deleting Service Account Key %q: %s", nameData.Name, err),
		)
		return
	}
}
